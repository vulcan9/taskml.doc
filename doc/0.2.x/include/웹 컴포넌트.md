# 사용자 컴포넌트 만들기

## 웹 컴포넌트 만들기

`CustomElement` 클래스를 상속하고 `customElements`에 등록하면 HTML 표준 웹 컴포넌트가 생성됩니다.
- [웹 컴포넌트](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_custom_elements)
- [customElements](https://developer.mozilla.org/ko/docs/Web/API/Window/customElements)
- [web-components-examples](https://github.com/mdn/web-components-examples/)

따라서 웹 컴포넌트의 모든 기능을 그대로 사용할 수 있습니다.  
taskML에서 컴포넌트를 작성하는 방법입니다.

```html
<div id="app" template="#taskml"></div>

<template id="taskml">

  <script type="module">
    import {CustomElement} from "/taskml";

    console.log('현재 파일 경로: ', `${$inject.dirname}`);
    
    // <custom-tag> 컴포넌트 로직
    class CustomTag extends CustomElement {
      // $inject 정보 전달 (필수 오버라이딩)
      // $inject 값은 파일마다 값이 다르므로 직접 오버라이딩 해줘야 합니다.
      getInject() { 
          return $inject; 
      }
    }

    // 컴포넌트 등록
    // 글자 가운데 "-" 를 하나 이상 포함해야 한다
    customElements.define('user-component', CustomTag);
  </script>

</template>
```
따라서, `CustomElement` 클래스를 상속하여 컴포넌트의 기능을 더 확장할 수 있습니다.

[사용자 컴포넌트 네이밍 규칙 (표준)](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define#valid_custom_element_names)
- ASCII 소문자(az)로 시작합니다.
- 하이픈이 포함되어 있습니다
- ASCII 대문자를 포함하지 않습니다
- 다음 특정 문자를 포함하면 컴포넌트 이름으로 사용할 수 없습니다.
    - "annotation-xml"
    - "color-profile"
    - "font-face"
    - "font-face-src"
    - "font-face-uri"
    - "font-face-format"
    - "font-face-name"
    - "missing-glyph"

## 웹 컴포넌트 사용하기

```html
<div id="app" template="#taskml"></div>
<template id="taskml">
  
  ...
  
  <!--taskML 내부에서 사용-->
  <user-component></user-component>
</template>

<!--웹 표준 컴포넌트이므로 taskML 바깥에서도 사용 가능합니다.-->
<user-component>
  <slot></slot>
</user-component>
```

# 웹 컴포넌트 기능 확장

```html
<user-component [useShadowRoot="false|open|close"]
                [template="#템플릿_아이디"] 
                [template-data="데이터_변수_이름"]>
  <slot></slot>
</user-component>
```

## `useShadowRoot` 속성

[Shadow DOM API (shadowRoot.mode)](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot)를 쉽게 설정함

ShadowRoot: 문서의 기본 DOM 트리와 별도로 렌더링되는 DOM 하위 트리의 루트 노드
- false: ShadowRoot 사용 안함
- open (default):
    - `ShadowRoot.mode = 'open'` 값으로 설정됨
    - 외부에서 element.shadowRoot로 Shadow DOM 접근 가능
- close:
    - `ShadowRoot.mode = 'close'` 값으로 설정됨
    - 외부에서 element.shadowRoot(=null)로 Shadow DOM 접근 불가능

```html
<user-component useShadowRoot="close"></user-component>
```

## `template` 속성

컴포넌트의 UI (구조 및 skin)를 설정합니다.

```html
<div id="app" template="#taskml"></div>
<template id="taskml">

  <!--컴포넌트 스킨 정의, data-name="data"-->
  <template id="userComponent" desc="임의의 attribute 설정값">
    <h3>User Component Skin</h3>
    <li>템플릿이 정의 문서의 경로 : ${$inject.dirname}</li>
  </template>

  <!--<user-component></user-component>-->
</template>
```

template을 찾을 수 있는 고유한 selector를 설정해 줍니다.  
(css selector 형식이면 모두 가능하나 중복되지 않는 id를 전달하는 것이 좋습니다.)

```html
<user-component template="#userComponent"></user-component>
<!--또는 다음 css selector도 가능함-->
<user-component template="template#userComponent"></user-component>
<user-component template="template[desc='임의의 attribute 설정값']"></user-component>
<user-component template="[desc='임의의 attribute 설정값']"></user-component>
<!-- ... 다른 여러 selector 형식 사용 가능함 -->
```

### 기본값 설정

`template` 속성의 기본값을 미리 정의하고 싶으면 `CustomElement` 클래스를 재정의 합니다.

```js
class CustomTag extends CustomElement {
  // ...
  
  // getInject 메서드는 꼭 오버라이딩 할것
  getInject() { return $inject; }
  
  // 기본 템플릿 설정 오버라이딩
  defaultTemplate() {
    // 현재 문서의 내부에서만 탐색 합니다.
    // 로드된 문서의 내용과 충돌을 방지하기 위해 this.getInject()를 사용합니다.
    const context = this.getInject();
    return context.template('#defaultSkin')[0];
  }
}
```

다음처럼 `template` 속성을 설정하지 않으면 기본값이 적용됩니다.

```html
<user-component></user-component>
```

### 주의할점

스킨으로 사용할 template 내부에 task를 정의하지 않는것이 좋습니다.

```html
<!--컴포넌트 스킨 정의-->
<template id="userComponent">
    <task id="클릭"></task>
    <div task:click="클릭">시작</div>
</template>
```

위의 경우 `#userComponent` 템플릿을 사용자 컴포넌트의 스킨으로 사용할 경우,  
인스턴스 생성시마다 "클릭" task가 재정의 됩니다.  
꼭 필요한 경우가 아니면 스킨 정의 밖에서 정의하세요.

```html
<define>
    <div task:click="클릭">시작</div>
    <template id="userComponent">
        <task id="클릭"></task>
    </template>
    <!-- ... -->
</define>
```

## `template-data` 속성

`template` 설정만으로는 컴포넌트의 자유로운 사용에 제한이 있습니다.  
컴포넌트를 사용하는 시점에 여러가지 설정값을 적용하고 싶을때 사용합니다.

```html
<div id="app" template="#taskml"></div>
<template id="taskml">

  <script>
    // 템플릿 데이터 정의
    const templateData = {
      text: '템플릿 데이터를 동적으로 적용합니다.'
    }
  </script>
  
  <!-- 
  컴포넌트 스킨 정의
  템플릿 리터럴 구문으로 데이터 사용 가능함 : ${data.text}
  -->
  <template id="userComponent">
    <h3>User Component Skin</h3>
    <li>데이터: ${JSON.stringify(data)}</li>
  </template>

  <!--<user-component></user-component>-->
</template>
```

`userComponent`template 스킨에 `templateData` 데이터를 적용합니다.
```html
<user-component template="#userComponent"
                template-data="templateData"></user-component>
```

### 기본값 설정

`template-data` 속성의 기본값을 미리 정의하고 싶으면 `CustomElement` 클래스를 재정의 합니다.

```js
class CustomTag extends CustomElement {
  // ...
  
  // getInject 메서드는 꼭 오버라이딩 할것
  getInject() { return $inject; }
  
  // 기본 템플릿 데이터 설정 오버라이딩
  defaultTemplateData() {
    return {
      text: '템플릿 데이터 (기본값)을 적용합니다.'
    }
  }
}
```

다음처럼 `template-data` 속성을 설정하지 않으면 기본값이 적용됩니다.

```html
<user-component template="#userComponent"></user-component>
```

### 주의할점

템플릿 데이터를 정의하는 스크립트는 문서 아무곳에서 정의해도 상관없습니다.  
다만 `<script type="module">` 처럼 모듈 설정이 필요할때에는 전역변수로 만들어 주세요

```html
<script type="module">
  // 템플릿 데이터 정의
  window.templateData = { ... }
</script>
```

### template에서 사용하는 데이터 이름

`template-data`를 받아 template에서 적용해 줄때, 받는 데이터의 이름을 설정할 수 있습니다.  
템플릿 정의 태그에서 `data-name` 속성을 사용합니다.

- `data-name="data (기본값)"` : templateData 데이터를 "data" 이름으로 받아 사용합니다.

```html
<!-- 컴포넌트 스킨 정의: "info" 이름으로 데이터 참조하기 -->
<template id="userComponent" data-name="info">
  <h3>User Component Skin</h3>
  <li>데이터: ${JSON.stringify(info)}</li>
</template>
```

복잡한 구조의 템플릿을 만들때 데이터 이름이 중복되지 않도록 하기 위해 필요합니다.

## `<template>` 사용 요약

* 지정된 이름으로 데이터 객체가 전달됨 : `data-name="data"`
* 템플릿 리터럴 구문으로 데이터 사용 가능함 : `${data.text}`
* task를 지정하려면 template 태그 외부에 설정하는 것이 좋음
  (template 안에 넣으면 인스턴스 개수만큼 task 재정의 됨)
* 템플릿 리터럴 구문을 사용할때에는 template 태그는 중첩되면 안됨
  (상위 템플릿에 template-data가 설정된 경우 상위 template의 데이터가 주입됨)


## `template-data`를 설정하는 경우 주의 사항
`template-data`를 설정하면 템플릿 리털러 구문이 있는 것으로 가정하여 `template-data`에 명시된 객체 이름으로 구문을 해석합니다.

만약 템플릿 내부에서 task을 정의한다면 `$args` 변수 참조구문 작성에 주의해야합니다.  
`template-data` 이름으로 구문을 해석할때 `${$args[0]}` 구문을 만나면 `$args` 겍체를 찾을 수 없다는 ReferenceError가 발생합니다.
```
// 에러 내용
Uncaught (in promise) ReferenceError: <변수명> is not defined
```
> task 내부에서 `${$args[0]}` 구문 대신 `$args[0]` 구문을 사용하세요

`$args` 뿐만 아니라 다른 변수를 참조했다면 해당 변수는 global 변수로 등록 되어 있어야 합니다.  
다음의 경우에는 에러가 발생되지 않습니다.
```html
<script>
    const templateData = {
        label: '제목'
    };
    const anotherData = '다른 리터럴 템플릿 변수 사용';
</script>

<!--템플릿 사용 설정-->
<div template="#templateID" template-data="templateData"></div>

<template id="templateID" data-name="data">
    ${data.label} - ${anotherData}
</template>
```
