# taskML 랜더링 과정

## 랜더링 과정 간략 설명

### 1. template 파싱

template 랜더링이 호출되면 내부적으로 다음 순서에 따라 화면을 랜더링 합니다.

> * taskml에서 "on"으로 시작되는 attribute은 모두 이벤트 핸들러를 위한 attribute으로 간주합니다.
> * 파싱되는 과정에서 핸들러는 등록되고 DOM atrtibute에서는 삭제될 수도 있습니다.
> * 0.2.0 버전부터 `preload`, `include` task 기능으로 외부 taskml 파일을 불러올 수 있습니다.

#### template 파싱 규칙

* DOM 및 inline script 태그가 순서대로 생성되고 실행 됩니다. (top-down)
* 도중에 `preload` task 구문을 만나면 해당 페이지 내용을 로드 & 파싱 완료 후 계속 진행합니다.
* 로드 과정에서 파싱된 순서대로 task 오버라이딩이 처리됩니다. (top-down)
* 모듈 script는 원래대로 DOM 생성이 완료된 후 실행됩니다.
* 외부 JS 파일을 로드하는 script 태그의 async, defer attribute 설정에 따른 실행 순서는 최대한 유지됩니다.

### 2. template 랜더링 시작

템플릿 내용은 최초 한번만 랜더링 됩니다.
> * task 컴포넌트, DOM 컴포넌트 태그는 `<template>` 태그 내에서만 사용할 수 있습니다.
> * 따라서 생성된 DOM에 `task:click` 같은 attribute을 동적으로 생성해 넣어도 동작하지 않습니다.

#### DOM 생성 (실행) 순서

1. DOM 요소가 top-down 순서로 생성되고 inline script도 이때 실행됩니다.
    - 중간에 `preload` 된 script가 있으면 `preload` 태그 위치에서 순서대로 함께 실행됩니다.
2. `domCreated` 이벤트가 발생합니다. (document custom 이벤트)
3. DOM 생성이 완료된 후 모듈 script가 로드 & 실행됩니다.
    - `preload`된 문서의 inline 모듈 script도 이때 실행됩니다.
4. `DOMContentLoaded` docuemnt 이벤트가 발생합니다.
5. `appCreated` 이벤트가 발생합니다. (document custom 이벤트)
6. 익명 Task가 자동으로 실행됩니다.
    - preload 문서의 익명 task도 DOM 구조(top-down) 순서대로 실행됩니다.
7. `include` 문서가 있으면 위 과정과 같은 순서로 파싱됩니다.


# 본문 문서의 실행 순서

> 스크립트 실행 순서는 HTML 실행시와 같은 순서로 동작합니다. (defer, async, module)

### 1. 본문 템플릿 파싱 단계

본문 `<template>` innerHTML 읽기
- `<template>`, `<task>`, `<scope>`, `<define>` 등을 모두 파싱해서 리소스로 등록만 합니다.
- 이때 아직 실제 DOM은 attach(렌더링) 안 됨, script도 실행 안 됨

### 2. DOM attach + 일반 `<script>` 실행 단계

- `<tag template="#...">` 가 있는 엘리먼트들이 실제 DOM으로 빌드되고
- 본문 노드를 순회하며 실제 DOM에 append
- inline `<script>` / `<script src>` (비모듈) 모두 실행
- `<script src>` 로드 완료까지 모두 기다림
- 이때 $inject 객체가 각각의 스크립트 실행 시점에 주입됩니다.

### 3. `domCreated` 이벤트 dispatch

- 모든 preload DOM attach 가 끝난 직후: `window.dispatchEvent(new Event('domCreated'))`
- 즉, DOM 구조가 모두 완성된 시점입니다.
- task, template, define 등 등록 끝 + 일반 스크립트 완료 상태

### 4. 모듈 스크립트 실행 단계

- `<script type="module">` 들이 이 단계에서 실행
- ES module import 실행 완료

### 5. `DOMContentLoaded` 이벤트 발생

- HTML 문서 표준 이벤트
- taskML 내부에서는 이 이벤트를 감지해서 `$firstrun.run()`을 트리거합니다.

### 6. `appCreated` 이벤트 dispatch

- 내부적으로 `$provider.emit('appCreated')`
- 이 시점에서 TaskML이 `앱 초기화 완료`로 간주합니다.

### 7. 본문의 익명 task 자동 실행 단계

이 단계가 `$firstrun` 큐에 등록된 순서로 실행됩니다.

(1) preload 블록의 익명 task 자동 실행
- 각 preload 문서의 `$firstrun` 큐에 등록된 익명 task 들 순서대로 실행됩니다.
- preload 1 → preload 2 → preload 3 …

(2) 본문 익명 task 자동 실행
- 마지막으로 본문(root)의 `$firstrun` 큐가 실행됩니다.

즉, `$firstrun.run()` 은 ① preload 쪽 먼저 → ② 본문 쪽 나중 순서로 호출됩니다.  
작업이 모두 끝나면 `$firstrun` 실행 큐를 비웁니다.

# 외부 문서를 로드할때 실행 순서

```html
<!--본문-->
<task preload="${$inject.dirname}/preload.html"></task>
```

외부 문서를 불러온다면 실행 순서는 다음과 같이 달라집니다.
- (2번) DOM Attach 단계 ~ (3번) `domCreated` 이벤트 발생 사이에 로드 문서 초기화 작업이 진행됩니다.
- 문서 초기화 단계는 본문 파싱 순서와 같습니다.
- 로드 문서의 익명 task(`$firstrun`) 작업은 본문 task (`$firstrun`) 작업 전에 실행됩니다. 

```
1. 본문 템플릿 파싱 단계
2. DOM attach + 일반 `<script>` 실행 단계

   # preload 1
   2-1. 외부 문서 파싱 단계
   2-2. 외부 문서의 DOM attach + 일반 `<script>` 실행 단계
   
       # preload 1-1 (child)
       child 노드중 preload가 있으면 여기에서 재귀 처리
   
   2-3. 외부 문서 모듈 스크립트 실행 단계
   2-4. 외부 문서 preload 완료

   # preload 2 ...
   # preload 3 ...

3. `domCreated` 이벤트 dispatch
4. 본문 모듈 스크립트 실행 단계

5. `DOMContentLoaded` 이벤트 발생
6. `appCreated` 이벤트 dispatch

   6-1. preload 블록 1의 익명 task 자동 실행
   # preload 블록 2의 익명 task 자동 실행
   # preload 블록 3의 익명 task 자동 실행 ...
   
7. 본문 익명 task 자동 실행 (`$firstrun`) 단계   
```




